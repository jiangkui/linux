# 《Linux 内核设计与实现》(第三版) 2017年06月27日
作者: Robert Love

## 检视阅读
### 包装
- 书名:
    - 《Linux 内核设计与实现》(第三版)
- 建议上架类别:
    - 计算机/程序设计
- 作者:
    - [Robert Love 罗伯特·拉姆](https://zh.wikipedia.org/wiki/%E7%BE%85%E4%BC%AF%E7%89%B9%C2%B7%E6%8B%89%E5%A7%86)
    - Linux 核心的主要开发者之一, 主要负责抢占式内核、进程调度器、内核事件层、通知机制、VM改进以及设备驱动程序。
        目前在 google 主要负责 Android 移动平台内核的团队成员。
- 作者Level(1-5星):
    - ★★★★
- 策划机构:
    - 华章科技
- 出版社:
    - 机械工业出版社
- 版次或印次:
    - 2015年10月第1版第9次印刷
### 整体
- 目录说了什么(大概说一下结构)
    - 内核简介、源码、进程管理、调度、系统调用、内核数据结构、中断和中断处理、下半部和推后执行的工作、内核同步介绍、内核同步方法、
        定时器和时间管理、内存管理、虚拟文件系统、块I/O层、进程地址空间、页高速缓存和页会写、设备与模块、调试、可移植性、补丁、
        开发和社区
- 本书的目的
    - 让读者对内核各个核心子系统有整体把握: 包括提供什么样的服务, 为什么要提供这样的服务, 以及如何实现的。
    - 还介绍了一些开发时需要的信息: 包括调试技术、编程风格、注意事项等等。
- 本书的目标
    - 提供足够多的关于 Linux 内核设计和实现的信息, 希望读者能够拥有较完备的知识, 可以真正开发内核代码。
- 本书受众群体
    - 核心内核开发者
    - 设备驱动开发者
    - 大学中作为介绍操作系统的辅助教材
- 阅读本书的前提条件
    - 已经掌握了 C 语言, 并且对 Linux 比较熟悉。

### 看细节
- 列举若干关键词: 内核、进程、内核数据结构、中断、下半部、同步、定时器、内存、虚拟文件系统、快I/O层、进程地址空间、页高速缓存、设备与模块、调试、可移植性
- 本书诚意度(1-5星)
    -  ★★★★

### 下判断
- 本书对我当下的价值
    - 了解 linux 系统内部的大概实现。
- 建议在什么时候继续阅读
    - 现在 (√)
    - 越早越好
    - 写入目标
    - 以后再说吧
- 建议采用什么方法阅读
    - 随便翻翻
    - 分析阅读 (√)
    - 主题阅读

### 粗阅读
- 简要书写阅读后的感受, 不超过300字。
- 从第三章开始, 每章都会介绍一个子系统, 但有一件事情需要意识到, 如果没意识到的话, 就会导致: 浪费很多时间, 学习效率不高, 坚持不下去等等情况。(学不会, 没有反馈, 必然坚持不下去。)
- 这件事情是: 阅读源码, 修改源码。而不是急着去看具体的子系统。要用一种抠的精神去学, 不要在意学习速度, 需要在意的是: 是否学会了。
- 原文: 第二章小结, 本章和以前的章节为贯穿本书剩余章节所讨论的主题奠定了基础。在后续的每一章中, 我们都会涵盖内核的一个具体概念或子系统。
在探索的征途中, 最重要的是`阅读和修改内核源码`, 只有通过实际的阅读和实践才会理解内核。

### 学到的理念

#### 系统规模逐渐扩大, 复杂程度不断提高, 内核开发者对内核了解越来越深入, 而新手却无法跟上内核的发展, 长此以往将出现断层。
解决方案:
- 尽量保证代码整洁: 接口定义合理, 代码风格一致, "一次做一件事, 做到完美", Linus Torvalds 的解决办法。

#### 不看源码, 就学不会

### 备注
- [清华大学网络技术研究所课程](http://www.tsinghua.edu.cn/publish/cs/4765/index.html)
    - 计算机组成原理
    - 操作系统
    - 计算机网络
    - 算法分析
    - 离散数学
    - 操作系统专题训练
    - 组合数学
    - 数据安全
    - 宽带网络交换技术


## 带着问题读书

### 画出 Linux 系统结构图
- [Linux 系统结构详解](http://blog.csdn.net/hguisu/article/details/6122513)
各个子系统关系, 实现细节,


## 打卡记录
### 2017年06月27日08:20:34 周二
产出: 写了部分【检视阅读】的笔记。
收获: 带着问题读书, 效率才高。
结束: 2017年06月27日10:12:36

### 2017年06月28日09:09:37 周三
产出: 完成【检视阅读】的笔记
收获: 意识到一个重要的问题: 不读源码, 就学不会实现原理。不实践, 印象就不深。
结束: 2017年06月28日10:02:08
代办: 下一个任务时, 把源码搞定, 能编译。

### 2017年06月29日09:02:23 周四
产出: 第一章节, 记录部分笔记。
收获: [看了一篇帖子: 你有什么? 你要什么? 你能放弃什么?](http://www.mbajyz.cn/rw/newsdetail/58239.html)
结束: 2017年06月29日10:38:59
代办: 源码、源码
问题: fork() 系统调用是干啥的?

### 2017年06月30日09:46:00 周五
产出: 无, 今天遇到一些事情, 不看书了。
收获:
结束:
代办:
问题:

### 2017年07月03日08:57:47 周一
产出: 一点笔记
收获:
结束: 2017年07月03日10:45:45
代办:
问题:

### 2017年07月04日09:43:23 周二
产出: 第一章, 笔记搞定。
收获: 通过单内核与多内核的比较, 对 Linux 内核设计理念与实现, 有了一个粗略的了解。
结束: 2017年07月04日10:14:24
代办: (已完成) 今天抽空弄好 VMware 虚拟机, 在上面搞一份代码。
问题:

### 2017年07月05日08:27:28 周三
产出: 2.1 章节笔记, 安装好 mac 的 VMware, 安装了一个 ubuntu 系统, 正在下载 stable(4.12) 版本的linux内核
收获: 了解从何处获取源码: linux 内核官网, 了解源码的各种版本, 使用 git 或 压缩包+补丁 的方式下载更新源码
结束: 2017年07月05日10:31:31

### 2017年07月06日08:45:06 周四
产出: linux 源码目录树, 具体功能的笔记
收获: 慢慢来, 学会了才有正向反馈, 才能坚持下去。
结束: 2017年07月06日10:11:01
代办: 重新画一个 linux 的目录树图。

### 2017年07月07日08:39:00 周五
产出: 详细了解linux 各个目录的功能以及wiki。
收获: 还挺好玩的
结束: 2017年07月07日10:10:45
代办: 编译源码, 安装。

### 2017年07月08日20:00:55 周六
产出: 内核源码编译安装完毕
收获: 用了5个作业来编译, 可能因为是虚拟机的原因, 还是花了很久才编译完成。
结束: 2017年07月08日20:49:54

### 2017年07月10日08:16:17 周一
产出: 内核源码编译安装完毕
收获: 用了5个作业来编译, 可能因为是虚拟机的原因, 还是花了很久才编译完成。
结束: 2017年07月08日20:49:54


## 译者序
Linux 的自由精神, 源码唾手可得。。
Linux 内核入门很难: 规模庞大, 层面复杂。
本书可以帮你舍弃细枝末节, 让你对核心子系统有整体把握, 包括它们提供了什么服务, 为什么要提供这样的服务, 以及如何实现。

## 第 1 章 Linux 内核简介
#### Unix 强大的跟本原因:
- Unix 很简洁:
    - Unix 仅有几百个系统调用, 并且有一个非常明确的设计目的。
- 高度抽象:
    - 所有的东西都被当做文件对待。
    - 对数据、对设备的操作都通过一套接口来调用: open()、read()、write()、lseek() 和 close();
- C语言编写:
    - 在硬件体系架构有惊人的移植能力, 并且是广大的开发人员很容易就能接受它。
- 进程创建迅速:
    - 创建迅速, 并且有一个独特的 fork() 系统调用。 `fork() 系统调用是干啥的?`
- 清晰的层次化结构:
    - 简单稳定的进程通信元语。
    - 快速简洁的进程创建策略、简单稳定的进程间通信机制。策略和机制分离的设计理念,保证了清晰的层次化结构。

#### 内核的组成:
- 中断服务程序:
    - 负责响应中断。由硬件设备产生异步的中断信号。
- 调度程序:
    - 负责管理多个进程分享处理器时间。
- 内存管理程序:
    - 管理进程地址空间。
- 系统服务程序:
    - 负责进程间通信。

#### 内核空间 用户空间
应用程序通过系统调用与内核通信。

#### 处理器的活动范围
- 用户空间: 执行用于进程
- 内核空间: 进程上下文, 代表某个特定的进程执行。
- 内核空间: 中断上下文, 与进程无关, 处理特定的中断。

#### Linux 与 Unix 内核的比较
- 单内核 与 多内核的设计比较
    - 单内核:
        - 整体是一个大过程
        - 单独的地址空间, 内核可以直接调用函数。
        - 大多数 Unix 系统都设计为单模块
    - 微内核:
        - 多个独立的过程
        - 各自独立的地址空间
        - 不能像单模块内核那样直接调函数, 通过消息传递处理内核同学。
        - 避免一个服务失效, 影响其他服务。
- Linux 的情况
    - Linux 是一个单内核
    - 吸取了微内核的精华:
        - 模块化设计、抢占式内核、支持内核线程、动态装载内核
        - 为避免微内核的缺陷, 让所有的事情都在内核态运行, 直接调函数, 无需消息传递。
- Linux 与 Unix 内核的比较
    - Linux 支持动态加载内核
    - Linux 支持对称多处理机制
    - Linux 内核可以抢占
    - Linux 不区分线程和其他一般的进程。
    - Linux 提供设备模型、热拔插事件, 用户空间的设备文件系统
    - 态度: 任何改变都必须要通过【简洁的设计】以及【可靠地实现】来解决问题。

#### 小结
- 内核的目标: 为达到目标所进行的设计以及设计的实现。
- 重点: 搞一份内核源码, 研究源码才能更清楚实现原理。
- 本书相当于一份内核源码的结构图, 可以让你拥有上帝视角。

## 第 2 章 从内核出发
本章主要介绍:
- 从何处获取源码: [Linux 内核官方网站](https://www.kernel.org/)
    - 使用 git 获取(书上强烈推荐, 因为下载完成, 可以很方便的更新, 但代码约780M, git下载很慢):
        - `git clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git`
        - kernel 官网有三种版本:
            - mainline: 主线版本, 最新的
            - stable: 稳定版本
            - longterm: 长期支持版本
    - 从内核官网下载压缩包:
        - 有各种格式的压缩包。
        - 使用补丁更新: `patch -p1 < ../patch-x.y.z` 一个补丁需要打在上一个版本上。
- 如何编译:
- 如何安装新内核:

### 2.1 获取内核源码
- Git 的起源: Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。它是分布式的。
- 内核源码一般放在 `/usr/src/linux` 目录下。不要动这个目录。建立自己的主目录, 用root身份安装新内核。

### 2.2 内核原码树

![Linux源代码目录结构说明](./img/linux_kernelImg.jpg)

以下为各个目录的说明, 附上两个参考链接:
- [参考链接:1.3 内核源代码的目录结构](https://github.com/tsuibin/kernelTools/wiki/1.3-%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84)
- [参考链接:Linux内核源码目录结构说明](http://ykzhai.top/2017/03/13/Linux/%E5%86%85%E6%A0%B8/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E/)

#### arch
包含特定硬件体系结构相关的代码, 每个子目录都代表一种Linux支持的体系结构。每个子目录又至少包含3个子目录
- kernel: 存放体系结构特有的诸如信号量处理和SMP之类特征的实现。
- lib: 存放体系结构特有的诸如strlen和memcpy之类的通用函数实现。
- mm: 存放体系结构特有的内存管理程序的实现。
- 除了这3个子目录之外，大多数体系结构在必要的情况下还有一个boot子目录，包含了在这种硬件平台上启动内核所使用的部分或全部平台特有代码。
- 此外，大部分体系结构所特有的子目录还根据需要包含了供附加特性使用的其他子目录。比如，i386目录包含一个math-emu子目录，其中包括了
在缺少数学协处理器（FPU）的CPU上运行模拟FPU的代码。

#### block
块设备驱动程序。I/O调度块设备驱动包括IDE（在ide.c中）驱动。块设备是以数据块方式接收和发送的数据的设备。

#### crypto
常用加密和散列算法(如:AES, SHA等), 还有一些压缩和 CRC 校验算法。

#### Documentation
内核相关文档

#### drivers
设备驱动程序，每个不同的驱动占用一个子目录。(由操作系统调用, 为软件服务。 firmware为硬件服务)

#### firmware (固件)
应用 --> 驱动 --> 固件 --> 硬件逻辑。
固件是为了操作硬件的, 留有接口让驱动来调用, 一般都是直接烧在硬件上。

fireware中包含了让计算机读取和理解从设备发来的信号的代码, ，举例来说，一个摄像头管理它自己的硬件，但计算机必须了解摄像头给计算机发送的
信号。Linux系统会使用vicam固件（firmware）来理解摄像头的通讯。否则，没有了固件，Linux系统将不知道如何处理摄像头发来的信息。另外，固
件同样有助于将Linux系统发送消息给该设备。这样Linux系统可以告诉摄像头重新调整或关闭摄像头。

#### fs
各种支持的文件系统, 如:ext、fat、ntfs等。

#### include
这个目录包含了内核中大部分的头文件，它按照下面的子目录进行分组。要修改处理器结构则只需编辑核心的makefile并重新运行Linux核心配置程序。
include/asm-*/ 每一个对应着一个arch的子目录，比如include/asm-alpha、Include/asm-arm等。每个子目录中的文件都定义了支持给定体系结构所必要的预处理函数和内联函数，这些内联函数多数都是全部或者部分的汇编语言实现。
include/linux 与平台无关的头文件都在这个目录下，它通常会被链接到目录/usr/include/linux(或者它里面的所有文件都会被复制到/usrinclude/linux目录下边)

#### init
内核的初始化代码。包括main.c、创建早起用户空间的代码及其他初始化代码。（注意不是系统引导代码）。

#### ipc
进程间通信(Inter Process Communication)，它包含了共享内存、信号量及其他形式的IPC代码。

#### kernel
内核中最核心的部分，包括进程的调度（sched.c）,以及进程的创建和撤销（fork.c和exit.c）和平台相关的另外一部分核心代码在arch/*/kernel目录下。

#### lib
此目录包含了核心的库代码。实现了一个标准C库的通用子集，包括字符串和内存操作的函数（strlen、mmcpy等）以及有关sprintf和atoi系列函数。
与arch/lib下的代码不同，这里的库代码都是C编写的，在内核新的移植版本中可以直接使用。与处理器结构相关库代码被放在arch/*/lib中。

#### mm
此目录包含了与体系无关的部分内存管理代码。与体系结构相关的内存管理代码位于arch/*/mm下

#### net
核心的网络部分代码，实现了各种常见的网络协议，入TCP/IP、IPX等

#### samples
一些内核编程的范例

#### scripts
用于配置内核文件的脚本文件。当运行make menuconfig或者make xconfig之类的命令配置内核时，用户就是和位于这个目录下的脚本进行交互的。

#### security
这个目录下包含了不同的Linux安全模型的代码。它对计算机免于受到病毒和黑客的侵害很重要。否则，Linux系统可能会遭到损坏。(主要是一个SELinux的模块)

#### sound
声卡驱动以及其他声音相关的源码(常用音频设备的驱动程序等)

#### tools
这个文件夹中包含了和内核交互的工具。

#### usr
实现用于打包和压缩的cpio等。这个文件夹中的代码在内核编译完成后创建这些文件。

#### virt
此文件夹包含了虚拟化代码，它允许用户一次运行多个操作系统。通过虚拟化，客户机操作系统就像任何其他运行在Linux主机的应用程序一样运行。

#### 其他
- COPYING: 文件是内核许可证(GNU GPL v2)
- CREDITS: 是内核代码的开发者列表。
- MAINTAINERS: 是维护者列表, 负责维护内核子系统和驱动程序
- Makefile: 是基本内核的 Makefile, 描述整个工程所有文件的编译顺序、编译规则。 make 是一个命令工具, 用来解释 Makefile 中的指令(规则)

### 2.3 内核编译
[参考链接:1.2 Linux内核的配置、编译与安装](https://github.com/tsuibin/kernelTools/wiki/1.2-Linux%E5%86%85%E6%A0%B8%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%81%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AE%89%E8%A3%85)

#### Linux 在编译前, 可以修改配置。

- make config: 遍历所有配置项, 让你选 yes、no或 module。
- make defconfig: 基于默认配置为你的体系结构创建一个配置。
- make: 内核配置ok, 就可以用此命令进行编译了。

#### 减少编译的垃圾信息
```
尽量减少垃圾信息, 又能看到错误和警告
make > .. /detritus

扔掉所有信息
make > /dev/null
```

#### 衍生多个编译作业
可以使用类似多线程的方式并发编译, 可以加快编译速度。 默认情况 make 只衍生一个作业, 防止多个依赖互相冲突。但内核 Makefile 不会有这样的编码错误, 所以可以用此方法。

```
n 是要衍生出作业数量。
make -jn

16核的机器可以用如下指令:
make -j32 > /dev/null
```

#### 2.3.4 安装新内核
编译完成后, 需要安装, 与体系结构和启动引导工具(boot loader)相关。

`make modules_install` 可以把编译好的模块安装到正确的主目录 /lib/modules 下。
编译时会在内核根目录下创建 System.map 文件, 这是一份符号对照表。将内核符号与他们的起始地址对应起来。